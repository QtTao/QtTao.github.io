<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>QtTao&#39;s Blog</title>
  <subtitle>团结 紧张 严肃 活泼</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-02-25T15:51:34.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Qitian Tao</name>
    <email>taoqt@mail2.sysu.edu.cn</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Python字符编码</title>
    <link href="http://yoursite.com/2017/02/25/python-character-coding/"/>
    <id>http://yoursite.com/2017/02/25/python-character-coding/</id>
    <published>2017-02-25T14:52:14.000Z</published>
    <updated>2017-02-25T15:51:34.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul>
<li>字节：计算机数据存储的基本单元。比如1 Byte = 8 bits。</li>
<li>字符：信息单位，它是各种文字和符号的统称。</li>
<li>字符集：某个范围内字符的集合，比如ASCII有128个字符，GB2312有7445个字符。</li>
<li>字符码：字符集中每个字符的数字编号，比如ASCII有编号0至127。</li>
<li>字符编码：将字符集中的字符码映射为字节流的一种具体实现方案，比如ASCII字符编码规定使用单字节中低位的7bits去编码所有字符。「A -&gt; 65 -&gt; 0X41 -&gt; b’01000001’」</li>
<li>编码（encode）：将字符转换成字节流。</li>
<li>解码（decode）：将字节流解析为字符。</li>
</ul>
<a id="more"></a>
<h2 id="ASCII码的历史"><a href="#ASCII码的历史" class="headerlink" title="ASCII码的历史"></a>ASCII码的历史</h2><p>英文字符只用一个字节的存储空间就能表示，比如1 Byte = 8 bits 代表256个字符。ASCII字符集由96个文字和32个控制符组成，只需要7位就能表示所有字符，剩下最高位被用作一些通讯系统的奇偶校验。由于西欧字符的数量远远超出ACSII码所能表达的范围，扩展ASCII码（EASCII）应运而生，EASCII由原来的ASCII码和一些表格符号，计算符号，希腊字母和拉丁符号组成。具体的字符范围是0x00～0x7F + 0x80 ～0xFF。代表性的字符集有CP437和ISO/8859-1。</p>
<h2 id="GBK"><a href="#GBK" class="headerlink" title="GBK"></a>GBK</h2><p>多字节字符的编码GBF是为了解决汉字在计算机中的表达的问题。一般汉字使用双字节来编码的。代表性的字符集有GB312（共有6763个汉字）和GBK（共有27484个汉字）。</p>
<h2 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h2><p>Unicode是一种通用的编码方式，它是用十六进制数字表示的，一般在数字前面加上前缀U+，比如A的Unicode编码是「U+0041」，「中」的Unicode编码是「U+4E2D」。Unicode有两种格式：UCS-2和UCS-4。</p>
<ul>
<li>UCS-2：使用两个字节，共16个比特，最多可以表达65536个字符</li>
<li>UCS-4: 使用四个字节，公32个比特，最高位通常为0。理论上可以涵盖一切语言所用的符号</li>
</ul>
<p>Unicode是也有其局限性的。例如一个Unicode字符在网络上传输或者存储起来的时候，并不见得每个字符都需要两个字节，如字符A，统一使用两个字节会大大地浪费空间。另外，如何判断哪两个字节是表示一个字符，这需要不同的Unicode编码实现方法，如UTF-8和UTF-16。</p>
<h3 id="UTF-8"><a href="#UTF-8" class="headerlink" title="UTF-8"></a>UTF-8</h3><p>Unicode Transformation Format，简称UTF-8是一种变长的字符编码实现方式，可以根据具体情况用1至4个字符来表示一个字符。比如英文自负这些原本就可以用ASCII码表示的字符用UTF-8表示时就只需要一个字节的空间，和ASCII是一样的。对于多字节的字符，第一个字节的前n位都设为1，第n+1位设为0，后面字节的前面两位都设为10。剩下的二进制位全部用该字符的Unicode码填充。以「陶」为例，「陶」的Unicode编码是「U+9676」，对应的UTF-8十六进制范围是00000800～0000FFFF，这表明了「陶」用UTF-8表示时需要用3个字节来存储，「U+9676」的二进制表示是1001011001110110，填充到1110xxxx 10xxxxxx 10xxxxxx得到11101001 10011001 10110110，转换成十六进制是e999b6。以下是Unicode和UTF-8转换关系表（x字符表示码点占据的位）。</p>
<table>
<thead>
<tr>
<th>起始值</th>
<th>终止值</th>
<th>Byte 1</th>
<th>Byte 2</th>
<th>Byte 3</th>
<th>Byte 4</th>
<th>Byte 5</th>
<th>Byte 6</th>
</tr>
</thead>
<tbody>
<tr>
<td>0000</td>
<td>007F</td>
<td>0xxxxxxx</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>0080</td>
<td>007FF</td>
<td>110xxxxx</td>
<td>10xxxxxx</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>0800</td>
<td>FFFF</td>
<td>1110xxxx</td>
<td>10xxxxxx</td>
<td>10xxxxxx</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>10000</td>
<td>1FFFFF</td>
<td>11110xxx</td>
<td>10xxxxxx</td>
<td>10xxxxxx</td>
<td>10xxxxxx</td>
<td></td>
<td></td>
</tr>
<tr>
<td>200000</td>
<td>3FFFFFF</td>
<td>111110xx</td>
<td>10xxxxxx</td>
<td>10xxxxxx</td>
<td>10xxxxxx</td>
<td>10xxxxxx</td>
<td></td>
</tr>
<tr>
<td>4000000</td>
<td>7FFFFFFF</td>
<td>1111110x</td>
<td>10xxxxxx</td>
<td>10xxxxxx</td>
<td>10xxxxxx</td>
<td>10xxxxxx</td>
<td>10xxxxxx</td>
</tr>
</tbody>
</table>
<h2 id="Python2编码"><a href="#Python2编码" class="headerlink" title="Python2编码"></a>Python2编码</h2><p>Python2默认编码是ASCII，所以在Python2中源代码文件必须显示地指定编码类型，否则但凡代码中出现有中文就会报语法错误。Python2中的字符串有两种类型，分别是str和unicode，它们都是继承自basestring类，而str类型的字符串的编码格式可以是ascii，utf-8，gbk等任何一种类型。</p>
<img src="/2017/02/25/python-character-coding/basestring.jpg" alt="basestring.jpg" title="">
<h3 id="str与unicode转换"><a href="#str与unicode转换" class="headerlink" title="str与unicode转换"></a>str与unicode转换</h3><p>这两种类型的字符串之间的转换靠的是decode和encode两个函数。encode负责将unicode编码成制定的字符编码，用语存储到磁盘或传输到网络种。而decode方法是根据指定编码方式解码后在应用程序种使用，所以从unicode转换到str用encode，从str类型转换到unicode则用decode。</p>
<img src="/2017/02/25/python-character-coding/str-unicode.jpg" alt="str-unicode.jpg" title="">
<h3 id="UnicodeEncodeError或者UnicodeDecodeError的原因"><a href="#UnicodeEncodeError或者UnicodeDecodeError的原因" class="headerlink" title="UnicodeEncodeError或者UnicodeDecodeError的原因"></a>UnicodeEncodeError或者UnicodeDecodeError的原因</h3><p>这些错误的根本原因在于Python2默认是使用ASCII编码进行decode和encode操作。</p>
<ol>
<li><p>案例1</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">s = <span class="string">'你好'</span>  <span class="comment"># str --&gt; decode</span></div><div class="line">s = <span class="string">u'你好'</span>  <span class="comment"># unicode --&gt; encode</span></div></pre></td></tr></table></figure>
</li>
<li><p>案例2<br>当str类型与unicode类型的字符串混合使用时，str类型字符串会隐式地将str转换成unicode字符串。「python2默认会使用ascii编码来进行decode操作。」</p>
</li>
<li>案例3<br>所有出现乱码的原因都可以归结为字符经过不同编码解码在编码过程种使用的编码格式不一致！比如utf-8编码的字符「陶」占用3个字节，解码成unicode后。如果再用gbk来解码后，只有两个字节长度了，最后出现了乱码问题，因此防止乱码的最好方式就是始终坚持使用同一种编码格式对字符进行编码和解码操作。</li>
</ol>
<img src="/2017/02/25/python-character-coding/tao-decode.jpg" alt="tao-decode.jpg" title="">
<h3 id="编码解码在Python中的实际应用"><a href="#编码解码在Python中的实际应用" class="headerlink" title="编码解码在Python中的实际应用"></a>编码解码在Python中的实际应用</h3><h4 id="encode-函数"><a href="#encode-函数" class="headerlink" title="encode()函数"></a>encode()函数</h4><p>encode函数的声明：S.encode([encoding[,errors]]) -&gt; object，作用是将str或者unicode编码成str，其中encoding参数指定的是编码结果字符串的编码类型，如果encoding没有指定的话，那么编码类型取sys.getdefaultencoding()。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/env python</span></div><div class="line"><span class="comment"># -*- coding: utf-8 -*-</span></div><div class="line"><span class="comment"># 将unicode编码成str，指定返回的str对象编码是gb2312</span></div><div class="line">u = <span class="string">u'中国汉字'</span></div><div class="line">s = u.encode(<span class="string">'gbk'</span>)</div><div class="line"></div><div class="line"><span class="comment"># 抛出UnicodeError错误，编码类型取sys.getdefaultcoding()，默认值为ascii，而ascii编码不支持中文</span></div><div class="line">u = <span class="string">u'中国汉字'</span></div><div class="line">s = u.encode()</div></pre></td></tr></table></figure></p>
<h4 id="decode-函数"><a href="#decode-函数" class="headerlink" title="decode()函数"></a>decode()函数</h4><p>decode函数的声明：S.decode([encoding[.errors]]) -&gt; string or unicode，作用是将一个str对象解码成unicode对象，其中encoding参数设置是被解码字符串的解码类型，而返回unicode对象的默认编码是utf-8。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/env python</span></div><div class="line"><span class="comment"># -*- coding: utf-8 -*-</span></div><div class="line"><span class="comment"># 抛出编码错误，写入文件时将unicode自动转换成str，然后str指定编码为ascii，但实际内容是以utf-8编码的汉字</span></div><div class="line">data = <span class="string">u'中国汉字'</span></div><div class="line"><span class="keyword">with</span> open(<span class="string">'file.txt'</span>, <span class="string">'w'</span>) <span class="keyword">as</span> fd:</div><div class="line">    fd.write(data)</div><div class="line"></div><div class="line"><span class="comment"># 解决方案1：手动编码unicode</span></div><div class="line">data = <span class="string">u'中国汉字'</span></div><div class="line"><span class="keyword">with</span> open(<span class="string">'file.txt'</span>, <span class="string">'w'</span>) <span class="keyword">as</span> fd:</div><div class="line">    fd.write(data.encode(<span class="string">'utf-8'</span>))</div><div class="line"></div><div class="line"><span class="comment"># 解决方案2：更改python默认指定编码 (不推荐)</span></div><div class="line"><span class="keyword">import</span> sys</div><div class="line">reload(sys)</div><div class="line">sys.setdefaultencoding(<span class="string">'utf-8'</span>)</div><div class="line">data = <span class="string">u'中国汉字'</span></div><div class="line"><span class="keyword">with</span> open(<span class="string">'file.txt'</span>, <span class="string">'w'</span>) <span class="keyword">as</span> fd:</div><div class="line">    fd.write(data.encode())</div><div class="line"></div><div class="line"><span class="comment"># 解决方案3：将python指定编码设置为系统默认语系的编码 （不推荐）</span></div><div class="line"><span class="keyword">import</span> sys, locale</div><div class="line">c = locale.getdefaultlocale()</div><div class="line">reload(sys)</div><div class="line">sys.setdefaultencoding(c[<span class="number">1</span>])</div><div class="line">data = <span class="string">u'中国汉字'</span></div><div class="line"><span class="keyword">with</span> open(<span class="string">'file.txt'</span>, <span class="string">'w'</span>) <span class="keyword">as</span> fd:</div><div class="line">    fd.write(data.encode())</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;字节：计算机数据存储的基本单元。比如1 Byte = 8 bits。&lt;/li&gt;
&lt;li&gt;字符：信息单位，它是各种文字和符号的统称。&lt;/li&gt;
&lt;li&gt;字符集：某个范围内字符的集合，比如ASCII有128个字符，GB2312有7445个字符。&lt;/li&gt;
&lt;li&gt;字符码：字符集中每个字符的数字编号，比如ASCII有编号0至127。&lt;/li&gt;
&lt;li&gt;字符编码：将字符集中的字符码映射为字节流的一种具体实现方案，比如ASCII字符编码规定使用单字节中低位的7bits去编码所有字符。「A -&amp;gt; 65 -&amp;gt; 0X41 -&amp;gt; b’01000001’」&lt;/li&gt;
&lt;li&gt;编码（encode）：将字符转换成字节流。&lt;/li&gt;
&lt;li&gt;解码（decode）：将字节流解析为字符。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
  </entry>
  
  <entry>
    <title>生产者/消费者模式</title>
    <link href="http://yoursite.com/2017/02/10/producers-consumers/"/>
    <id>http://yoursite.com/2017/02/10/producers-consumers/</id>
    <published>2017-02-10T13:57:27.000Z</published>
    <updated>2017-02-10T14:27:54.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><strong>生产者消费者问题</strong>，也称有限缓冲问题（Bounded-buffer problem）是一个多线程同步问题的经典案例。该问题描述了两个共享固定大小缓冲区的线程——即所谓的“生产者”和“消费者”——在实际运行时会发生问题。生产者的主要作用是生成一定量的数据放到缓冲区中，然后重复此过程。与此同时，消费者也在缓冲区消耗这些数据。该问题的关键就是要保证生产者不会在缓冲区满时加入数据，消费者也不会在缓冲区中空时消耗数据。</p>
<ul>
<li>生产者在缓冲区满时休眠，等到下次消费者消耗缓冲区中的数据的时候，生产者才能被唤醒，开始往缓冲区添加数据</li>
<li>消费者在缓冲区空时进入休眠，等到生产者往缓冲区添加数据之后，再唤醒消费者</li>
</ul>
<a id="more"></a>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># -*- coding: utf-8 -*</span></div><div class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Condition</div><div class="line"><span class="keyword">import</span> time</div><div class="line"><span class="keyword">import</span> random</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">condition = Condition()</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConsumerThread</span><span class="params">(Thread)</span>:</span></div><div class="line">    <span class="string">""" Consumer """</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">global</span> queue</div><div class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">            condition.acquire()</div><div class="line">            <span class="comment"># 在消费前检查队列是否为空</span></div><div class="line">            <span class="keyword">if</span> <span class="keyword">not</span> queue:</div><div class="line">                <span class="keyword">print</span> <span class="string">"Nothing in queue, consumer is waiting"</span></div><div class="line">                <span class="comment"># 如果为空，调用condition实例的wait()方法</span></div><div class="line">                condition.wait()</div><div class="line">                <span class="keyword">print</span> <span class="string">"Producer added something to queue and notified the consumer"</span></div><div class="line">            num = queue.pop(<span class="number">0</span>)</div><div class="line">            <span class="keyword">print</span> <span class="string">"Consumed"</span>, num</div><div class="line">            condition.release()</div><div class="line">            time.sleep(random.random())</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProducerThread</span><span class="params">(Thread)</span>:</span></div><div class="line">    <span class="string">""" Producer """</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></div><div class="line">        nums = range(<span class="number">5</span>)</div><div class="line">        <span class="keyword">global</span> queue</div><div class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">            condition.acquire()</div><div class="line">            num = random.choice(nums)</div><div class="line">            queue.append(num)</div><div class="line">            <span class="keyword">print</span> <span class="string">"Produced"</span>, num</div><div class="line">            <span class="comment"># 调用notify()方法后，consumer被唤醒，但唤醒不意味着它可以运行</span></div><div class="line">            condition.notify()</div><div class="line">            <span class="comment"># notify()并不是释放lock，调用notify()后，lock依然被生产者所持有</span></div><div class="line">            condition.release()</div><div class="line">            time.sleep(random.random())</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    ProducerThread().start()</div><div class="line">    ConsumerThread().start()</div></pre></td></tr></table></figure>
<h2 id="队列限制"><a href="#队列限制" class="headerlink" title="队列限制"></a>队列限制</h2><p><strong>为队列增加大小限制</strong>，即生产者不能向一个满队列继续加入数据。</p>
<ul>
<li>在加入数据前，生产者检查队列是否为满</li>
<li>如果不为满，生产者可以继续正常流程</li>
<li>如果为满，生产者必须等待，调用condition实例的wait()</li>
<li>消费者消耗对列，然后notify生产者</li>
<li>当消费者释放lock，消费可以acquire这个lock然后往队列中加入数据</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># -*- coding: utf-8 -*</span></div><div class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread, Condition</div><div class="line"><span class="keyword">import</span> time</div><div class="line"><span class="keyword">import</span> random</div><div class="line">queue = []</div><div class="line">MAX_NUM = <span class="number">10</span></div><div class="line">condition = Condition()</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProducerThread</span><span class="params">(Thread)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></div><div class="line">        nums = range(<span class="number">5</span>)</div><div class="line">        <span class="keyword">global</span> queue</div><div class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">            condition.acquire()</div><div class="line">            <span class="keyword">if</span> len(queue) == MAX_NUM:</div><div class="line">                <span class="keyword">print</span> <span class="string">"Queue full, producer is waiting"</span></div><div class="line">                condition.wait()</div><div class="line">                <span class="keyword">print</span> <span class="string">"Space in queue, Consumer notified the producer"</span></div><div class="line">            num = random.choice(nums)</div><div class="line">            queue.append(num)</div><div class="line">            <span class="keyword">print</span> <span class="string">"Produced"</span>, num</div><div class="line">            condition.notify()</div><div class="line">            condition.release()</div><div class="line">            time.sleep(random.random())</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConsumerThread</span><span class="params">(Thread)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">global</span> queue</div><div class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">            condition.acquire()</div><div class="line">            <span class="keyword">if</span> <span class="keyword">not</span> queue:</div><div class="line">                <span class="keyword">print</span> <span class="string">"Nothing in queue, consumer is waiting"</span></div><div class="line">                condition.wait()</div><div class="line">                <span class="keyword">print</span> <span class="string">"Producer added something to queue and notified the consumer"</span></div><div class="line">            num = queue.pop(<span class="number">0</span>)</div><div class="line">            <span class="keyword">print</span> <span class="string">"Consumed"</span>, num</div><div class="line">            condition.notify()</div><div class="line">            condition.release()</div><div class="line">            time.sleep(random.random())</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    ProducerThread().start()</div><div class="line">    ConsumerThread().start()</div></pre></td></tr></table></figure>
<p>特别地，Queue封装了Condition的行为，如wait()，notify()，acquire()。使用Queue可以方便的实现以上功能。注意get()和put()都有适当的notify()。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># -*- coding: utf-8 -*</span></div><div class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</div><div class="line"><span class="keyword">import</span> time</div><div class="line"><span class="keyword">import</span> random</div><div class="line"><span class="keyword">from</span> Queue <span class="keyword">import</span> Queue</div><div class="line"></div><div class="line">queue = Queue(<span class="number">10</span>)</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProducerThread</span><span class="params">(Thread)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></div><div class="line">        nums = range(<span class="number">5</span>)</div><div class="line">        <span class="keyword">global</span> queue</div><div class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">            num = random.choice(nums)</div><div class="line">            <span class="comment"># put()在插入数据前有一个获取lock的逻辑，同时，put()也会检查队列是否已满。如果已满，它会在内部调用wait()，生产者开始等待</span></div><div class="line">            queue.put(num)</div><div class="line">            <span class="keyword">print</span> <span class="string">"Produced"</span>, num</div><div class="line">            time.sleep(random.random())</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConsumerThread</span><span class="params">(Thread)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">global</span> queue</div><div class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">            <span class="comment"># get()从队列中移出数据前会获取lock</span></div><div class="line">            <span class="comment"># get()会检查队列是否为空，如果为空，消费者进入等待状态</span></div><div class="line">            num = queue.get()</div><div class="line">            <span class="comment"># 在完成一项工作之后，Queue.task_done()函数向任务已经完成的队列发送一个信号，详见Python之多线程</span></div><div class="line">            <span class="comment"># Queue.task_done()用于统计在队列中未完成的任务，这样Queue.join()就能获知任务的结束</span></div><div class="line">            queue.task_done()</div><div class="line">            <span class="keyword">print</span> <span class="string">"Consumed"</span>, num</div><div class="line">            time.sleep(random.random())</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    ProducerThread().start()</div><div class="line">    ConsumerThread().start()</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;生产者消费者问题&lt;/strong&gt;，也称有限缓冲问题（Bounded-buffer problem）是一个多线程同步问题的经典案例。该问题描述了两个共享固定大小缓冲区的线程——即所谓的“生产者”和“消费者”——在实际运行时会发生问题。生产者的主要作用是生成一定量的数据放到缓冲区中，然后重复此过程。与此同时，消费者也在缓冲区消耗这些数据。该问题的关键就是要保证生产者不会在缓冲区满时加入数据，消费者也不会在缓冲区中空时消耗数据。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;生产者在缓冲区满时休眠，等到下次消费者消耗缓冲区中的数据的时候，生产者才能被唤醒，开始往缓冲区添加数据&lt;/li&gt;
&lt;li&gt;消费者在缓冲区空时进入休眠，等到生产者往缓冲区添加数据之后，再唤醒消费者&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>multiprocessing.Pool的进程锁</title>
    <link href="http://yoursite.com/2017/02/04/multiprocessing-pool-lock/"/>
    <id>http://yoursite.com/2017/02/04/multiprocessing-pool-lock/</id>
    <published>2017-02-04T09:16:51.000Z</published>
    <updated>2017-02-25T14:56:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>通常情况下，python标准库中的multiprocessing.Lock对象是不可以作为进程池Pool的参数，这是因为进程锁不能通过pickle序列化。以下提供两种方法允许在多进程使用过程中引入进程锁，解决资源竞争问题。</p>
<h2 id="参数绑定"><a href="#参数绑定" class="headerlink" title="参数绑定"></a>参数绑定</h2><p>实例化Manager()和创建Manager.Lock()，但是使用Manager会产生大量的进程，同时所有获取锁和释放锁的请求都会发送给Manager，这样会造成进程资源的消耗。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> multiprocessing</div><div class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> partial</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></div><div class="line">    iterable = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</div><div class="line">    pool = multiprocessing.Pool()</div><div class="line">    m = multiprocessing.Manager()</div><div class="line">    l = m.Lock()</div><div class="line">    <span class="comment"># functool.partial作用是把keywords，args的参数传入到func中后，生成一个新的函数，其实仍然是func函数，只是有部分参数已经代入</span></div><div class="line">    <span class="comment"># 这里是为了解决pool.map函数只接受一个iterator作为参数，所以需要将iterator和进程锁绑定在一起</span></div><div class="line">    func = partial(target, l)</div><div class="line">    pool.map(func, iterable)</div><div class="line">    pool.close()</div><div class="line">    pool.join()</div></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="将进程锁置为全局变量"><a href="#将进程锁置为全局变量" class="headerlink" title="将进程锁置为全局变量"></a>将进程锁置为全局变量</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> multiprocessing</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">target</span><span class="params">(iterable_item)</span>:</span></div><div class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> items:</div><div class="line">        <span class="keyword">if</span> some conditions:</div><div class="line">            <span class="keyword">with</span> lock:</div><div class="line">                <span class="comment"># write to stdout or logfile, etc</span></div><div class="line">                <span class="keyword">pass</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">init</span><span class="params">(l)</span>:</span></div><div class="line">    <span class="keyword">global</span> lock</div><div class="line">    lock = l</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></div><div class="line">    iterable = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</div><div class="line">    l = multiprocessing.Lock()</div><div class="line">    poll = multiprocessing.Pool(initializer=init, initargs=(l,))</div><div class="line">    pool.map(target, iterable)</div><div class="line">    pool.close()</div><div class="line">    pool.join()</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;通常情况下，python标准库中的multiprocessing.Lock对象是不可以作为进程池Pool的参数，这是因为进程锁不能通过pickle序列化。以下提供两种方法允许在多进程使用过程中引入进程锁，解决资源竞争问题。&lt;/p&gt;
&lt;h2 id=&quot;参数绑定&quot;&gt;&lt;a href=&quot;#参数绑定&quot; class=&quot;headerlink&quot; title=&quot;参数绑定&quot;&gt;&lt;/a&gt;参数绑定&lt;/h2&gt;&lt;p&gt;实例化Manager()和创建Manager.Lock()，但是使用Manager会产生大量的进程，同时所有获取锁和释放锁的请求都会发送给Manager，这样会造成进程资源的消耗。&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; multiprocessing&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; functools &lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; partial&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;:&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    iterable = [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    pool = multiprocessing.Pool()&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    m = multiprocessing.Manager()&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    l = m.Lock()&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;# functool.partial作用是把keywords，args的参数传入到func中后，生成一个新的函数，其实仍然是func函数，只是有部分参数已经代入&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;# 这里是为了解决pool.map函数只接受一个iterator作为参数，所以需要将iterator和进程锁绑定在一起&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    func = partial(target, l)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    pool.map(func, iterable)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    pool.close()&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    pool.join()&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
      <category term="多进程" scheme="http://yoursite.com/tags/%E5%A4%9A%E8%BF%9B%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>堆排序</title>
    <link href="http://yoursite.com/2017/02/02/heapsort/"/>
    <id>http://yoursite.com/2017/02/02/heapsort/</id>
    <published>2017-02-02T15:55:13.000Z</published>
    <updated>2017-02-04T09:06:07.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>堆的定义如下：</p>
<ol>
<li>堆是一颗完全二叉树；</li>
<li>堆中的某个节点的值总是不大于或不小于其孩子节点的值；</li>
<li>堆中每个节点的子堆都是堆；</li>
</ol>
<p>当父节点的键值总是大于或者等于任何一个子节点的键值时为最大堆。当父节点的键值总是小于或者等于任何一个子节点的键值时未最小堆。如下图所示，左边为最大堆，右边为最小堆。</p>
<img src="/2017/02/02/heapsort/heap.jpg" alt="heap.jpg" title="">
<a id="more"></a>
<h2 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h2><p>首先把有n个元素的数组a初始化创建为最大堆，然后循环执行如下过程直到数组为空为止：</p>
<ol>
<li>把堆顶a[0]元素（为最大元素）和当前最大堆的最后一个元素交换；</li>
<li>最大堆元素个数减一；</li>
<li>由于第一步后根结点不再满足最大堆的定义，因此调整根结点使之满足最大堆的定义；</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateHeap</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n, <span class="keyword">int</span> h)</span> </span>&#123;</div><div class="line"><span class="comment">/* 当完全二叉树中某个非叶结点a[h]（h = (n - 2)/2）的左孩子结点a[2h + 1]和右孩子结点a[2h + 2]都已是最大堆后，调整一个非叶结点a[h]使之满足最大堆。 */</span></div><div class="line">    <span class="keyword">int</span> i, j, flag;</div><div class="line">    <span class="keyword">int</span> temp;</div><div class="line">    <span class="comment">/* i为要建堆的二叉树根结点下标 */</span></div><div class="line">    i = h;</div><div class="line">    <span class="comment">/* j为i的左孩子结点的下标 */</span></div><div class="line">    j = <span class="number">2</span> * i + <span class="number">1</span>;</div><div class="line">    temp = a[i];</div><div class="line">    flag = <span class="number">0</span>;</div><div class="line">    <span class="comment">/* 沿左右孩子中值较大者重复向下筛选 */</span></div><div class="line">    <span class="keyword">while</span> (j &lt; n &amp;&amp; flag != <span class="number">1</span>) &#123;</div><div class="line">        <span class="comment">/* 寻找左右孩子结点中较大者， */</span></div><div class="line">        <span class="keyword">if</span> (j &lt; n - <span class="number">1</span> &amp;&amp; a[j] &lt; a[j + <span class="number">1</span>])</div><div class="line">            j++;</div><div class="line">        <span class="keyword">if</span> (temp &gt; a[i]) &#123;</div><div class="line">            flag = <span class="number">1</span>;</div><div class="line">        <span class="comment">/* 否则把a[j]上移 */</span></div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            a[i] = a[j];</div><div class="line">            i = j;</div><div class="line">            j = <span class="number">2</span> * i + <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    a[i] = temp;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitCreateHeap</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">    <span class="comment">/* 把数组元素a[0]~a[n - 1]初始化创建为最大堆 */</span></div><div class="line">    <span class="keyword">int</span> i;</div><div class="line">    <span class="keyword">for</span> (i = (n - <span class="number">2</span>)/<span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)</div><div class="line">        CreateHeap(a, n, i);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> i;</div><div class="line">    <span class="keyword">int</span> temp;</div><div class="line">    <span class="comment">/* 初始化创建最大堆 */</span></div><div class="line">    InitCreateHeap(a, n);</div><div class="line">    <span class="comment">/* 当前最大堆个数每次递减一 */</span></div><div class="line">    <span class="keyword">for</span> (i = n - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</div><div class="line">        temp = a[<span class="number">0</span>];</div><div class="line">        a[<span class="number">0</span>] = a[i];</div><div class="line">        a[i] = temp;</div><div class="line">        <span class="comment">/* 调整根结点满足最大堆 */</span></div><div class="line">        <span class="comment">/* 子二叉树的根结点下标为零，结点个数为i */</span></div><div class="line">        CreateHeap(a, i, <span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;堆&quot;&gt;&lt;a href=&quot;#堆&quot; class=&quot;headerlink&quot; title=&quot;堆&quot;&gt;&lt;/a&gt;堆&lt;/h2&gt;&lt;p&gt;堆的定义如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;堆是一颗完全二叉树；&lt;/li&gt;
&lt;li&gt;堆中的某个节点的值总是不大于或不小于其孩子节点的值；&lt;/li&gt;
&lt;li&gt;堆中每个节点的子堆都是堆；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;当父节点的键值总是大于或者等于任何一个子节点的键值时为最大堆。当父节点的键值总是小于或者等于任何一个子节点的键值时未最小堆。如下图所示，左边为最大堆，右边为最小堆。&lt;/p&gt;
&lt;img src=&quot;/2017/02/02/heapsort/heap.jpg&quot; alt=&quot;heap.jpg&quot; title=&quot;&quot;&gt;
    
    </summary>
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="排序" scheme="http://yoursite.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>关于图的知识点</title>
    <link href="http://yoursite.com/2017/02/01/graph/"/>
    <id>http://yoursite.com/2017/02/01/graph/</id>
    <published>2017-02-01T15:18:10.000Z</published>
    <updated>2017-02-04T08:38:11.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="图的存储结构"><a href="#图的存储结构" class="headerlink" title="图的存储结构"></a>图的存储结构</h2><ul>
<li>邻接矩阵（稠密矩阵：点少边多的情况）</li>
<li>邻接表 （稀疏矩阵：点多边少的情况）</li>
</ul>
<h2 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h2><ul>
<li>深度优先</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">void DepthFSearch(AdjMGraph G, int v, int visited[], void Visit(char item))</div><div class="line">&#123;</div><div class="line">    int w;</div><div class="line">    Visit(G.Vertices.list[v]);</div><div class="line">    visited[v];</div><div class="line">    w = GetFirstVex(G, v);</div><div class="line">    /* 寻找当前顶点的邻接顶点 */</div><div class="line">    while (w != -1)</div><div class="line">    &#123;</div><div class="line">        if (!visited[w])</div><div class="line">            DepthFSearch(G, w, visited, Visit)</div><div class="line">        /* 若邻接顶点已被访问，则寻找下一个邻接顶点 */</div><div class="line">        w = GetNextVex(G, v, w);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<a id="more"></a>
<ul>
<li>广度优先</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">void BoardFSearch(AdjMGraph G, int v, int visited[], void Visit(char item))</div><div class="line">&#123;</div><div class="line">    int u, w;</div><div class="line">    SeqCQueue queue;</div><div class="line">    QueueInitiate(&amp;queue);</div><div class="line">    Visit(G.Vertices.list[v]);</div><div class="line">    visited[v];</div><div class="line">    QueueAppend(&amp;queue, v);</div><div class="line">    /* 当队列为空时终止循环 */</div><div class="line">    while(QueueNotEmpty(queue))</div><div class="line">    &#123;</div><div class="line">        QueueDelete(&amp;queue, &amp;u);</div><div class="line">        w = GetFirstVex(G, u);</div><div class="line">        /* 遍历所有邻接顶点 */</div><div class="line">        while(w != -1)</div><div class="line">        &#123;</div><div class="line">            if (!visited[w])</div><div class="line">            &#123;</div><div class="line">                Visit(G.Vertices.list[w]); // 访问顶点w</div><div class="line">                visited[w]; // 标记顶点w</div><div class="line">                QueueAppend(&amp;queue, w); // 顶点w入队列</div><div class="line">            &#125;</div><div class="line">            w = GetNextVex(G, u, w);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="最小生成树－无向带权连通图"><a href="#最小生成树－无向带权连通图" class="headerlink" title="最小生成树－无向带权连通图"></a>最小生成树－无向带权连通图</h2><p>对于无向带权连通图，其所有生成树中边的权值总和最小的是最小生成树。例如在n个城市之间敷设光缆，且各城市之间敷设光缆的费用不同。</p>
<p>n个顶点的无向连通带权图的最小生成树必须满足如下条件：</p>
<ul>
<li>包括n个顶点</li>
<li>有且只有n - 1条边</li>
<li>不存在回路</li>
</ul>
<h3 id="经典算法"><a href="#经典算法" class="headerlink" title="经典算法"></a>经典算法</h3><ul>
<li>Prim algorithm （点少边多，稠密矩阵）</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></div><div class="line">&#123;</div><div class="line">    Vert vertex;</div><div class="line">    <span class="keyword">int</span> weight;</div><div class="line">&#125; MinSpanTree;</div><div class="line"><span class="comment">/* Prim algorithm */</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Prim</span><span class="params">(AdjMGraph G, MinSpanTree closeVertex[])</span></span></div><div class="line">&#123;</div><div class="line">    Vert x;</div><div class="line">    <span class="keyword">int</span> i, j, k;</div><div class="line">    <span class="keyword">int</span> minCost;</div><div class="line">    <span class="keyword">int</span> n = G.Vertices.size;</div><div class="line">    <span class="keyword">int</span> * lowCost = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * n);</div><div class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n; i ++)</div><div class="line">        lowCost[i] = G.edge[<span class="number">0</span>][i];</div><div class="line">    lowCost[<span class="number">0</span>] = <span class="number">-1</span>;</div><div class="line">    listGet(G.Vertices, <span class="number">0</span>, &amp;x);</div><div class="line">    closeVertex[<span class="number">0</span>].vertex = x;</div><div class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n; i++)</div><div class="line">    &#123;</div><div class="line">        minCost = MaxWeight; <span class="comment">// MaxWeight为定义的最大权值</span></div><div class="line">        <span class="comment">/* 寻找当前最小权值的边所对应的顶点k，但不包括lowCost = -1的 */</span></div><div class="line">        <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; n; j++)</div><div class="line">            <span class="keyword">if</span> (minCost &gt; lowCost[j] &amp;&amp; lowCost[j] &gt; <span class="number">0</span>)</div><div class="line">            &#123;</div><div class="line">                k = j;</div><div class="line">                minCost = lowCost[j];</div><div class="line">            &#125;</div><div class="line">        listGet(G.Vertices, k, &amp;x);</div><div class="line">        closeVertex[i].vertex = x;</div><div class="line">        closeVertex[i].weight = minCost;</div><div class="line">        lowCost[k] = <span class="number">-1</span>;</div><div class="line">        <span class="comment">/* 更新权值 */</span></div><div class="line">        <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; n; j++)</div><div class="line">            <span class="keyword">if</span> (lowCost[j] &gt; G.edge[k][j])</div><div class="line">                lowCost = G.edge[k][j];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>Kruskal算法（点多边少，稀疏矩阵）：首先是带权图中各边的权值排序，其次是判断新选取的边的两个顶点是否属于同一个连通分量。</li>
</ul>
<h2 id="最短路径－有向带权图（连通／非连通）"><a href="#最短路径－有向带权图（连通／非连通）" class="headerlink" title="最短路径－有向带权图（连通／非连通）"></a>最短路径－有向带权图（连通／非连通）</h2><h3 id="经典算法-1"><a href="#经典算法-1" class="headerlink" title="经典算法"></a>经典算法</h3><ul>
<li>Dijkstra algorithm：按路径长度递增的顺序逐步产生最短路径的构造算法</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(AdjMGraph G, <span class="keyword">int</span> v0, <span class="keyword">int</span> distance[], <span class="keyword">int</span> path[])</span></span></div><div class="line"><span class="comment">/* s[]用来表示顶点是否已从集合T移动到集合S中 */</span></div><div class="line"><span class="comment">/* path[]存放了从原点v0到其它各个顶点的最短路径的前一个顶点的下标 */</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> n = G.Vertices.size;</div><div class="line">    <span class="keyword">int</span> * s = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * n);</div><div class="line">    <span class="keyword">int</span> minDis, i, j, k;</div><div class="line">    <span class="comment">/* Initilization */</span></div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n;  i++)</div><div class="line">    &#123;</div><div class="line">        distance[i] = G.edge[v0][j];</div><div class="line">        s[i] = <span class="number">0</span>;</div><div class="line">        <span class="keyword">if</span> (i != v0 &amp;&amp; distance[i] &lt; MaxWeight) path[i] = v0;</div><div class="line">        <span class="keyword">else</span> path[i] = <span class="number">-1</span>;</div><div class="line">    &#125;</div><div class="line">    s[v0] = <span class="number">1</span>;</div><div class="line">    <span class="comment">/* 对于连通图来说，每一个循环能找到一个路径最短的顶点 */</span></div><div class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n; i++)</div><div class="line">    &#123;</div><div class="line">        minDis = MaxWeight;</div><div class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span> (s[i] == <span class="number">0</span> &amp;&amp; minDis &gt; distance[j])</div><div class="line">            &#123;</div><div class="line">                k = j;</div><div class="line">                minDis = distance[j];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">/* 当不再存在路径时，算法结束。此语句对非连通图是必需的 */</span></div><div class="line">        <span class="keyword">if</span> (minDis == MaxWeight) <span class="keyword">return</span>;</div><div class="line">        s[k] = <span class="number">1</span>;</div><div class="line">        <span class="comment">/* 修改从v0到其它顶点的最短路径 */</span></div><div class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++)</div><div class="line">            <span class="keyword">if</span> (s[i] == <span class="number">0</span> &amp;&amp; G.edge[k][j] &lt; MaxWeight &amp;&amp; distance[k] + G.edge[k][j] &lt; distance[j])</div><div class="line">                distance[j] = distance[k] + G.edge[k][j];</div><div class="line">                path[j] = k;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>Floyd algorithm：解决每对顶点之间最短路径的算法。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;图的存储结构&quot;&gt;&lt;a href=&quot;#图的存储结构&quot; class=&quot;headerlink&quot; title=&quot;图的存储结构&quot;&gt;&lt;/a&gt;图的存储结构&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;邻接矩阵（稠密矩阵：点少边多的情况）&lt;/li&gt;
&lt;li&gt;邻接表 （稀疏矩阵：点多边少的情况）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;图的遍历&quot;&gt;&lt;a href=&quot;#图的遍历&quot; class=&quot;headerlink&quot; title=&quot;图的遍历&quot;&gt;&lt;/a&gt;图的遍历&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;深度优先&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;void DepthFSearch(AdjMGraph G, int v, int visited[], void Visit(char item))&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    int w;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    Visit(G.Vertices.list[v]);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    visited[v];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    w = GetFirstVex(G, v);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    /* 寻找当前顶点的邻接顶点 */&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    while (w != -1)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        if (!visited[w])&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            DepthFSearch(G, w, visited, Visit)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        /* 若邻接顶点已被访问，则寻找下一个邻接顶点 */&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        w = GetNextVex(G, v, w);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="图" scheme="http://yoursite.com/tags/%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>快速排序</title>
    <link href="http://yoursite.com/2017/02/01/quicksort/"/>
    <id>http://yoursite.com/2017/02/01/quicksort/</id>
    <published>2017-02-01T15:07:16.000Z</published>
    <updated>2017-02-02T15:59:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>快速排序（Quicksort) 在平均状况下，排序n个项目要O(nlogn)次比较。在最坏状况下则需要O(n2)次比较，但这种状况并不常见。它在排序效率同为O(nlogn)的几种排序方法中效率最高，因此经常被采用。</p>
<h2 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h2><p>设数组a中存放了n个数据元素，low为数组的低端下标，high为数组的高端下标，从数组a中任取一个元素（通常取a[low]）作为标准，调整数组a中各个元素的位置，使排在标准元素前面的元素的关键字均小于标准元素的关键字，排在标准元素后面的元素的关键字均大于或等于标准元素的关键字。（即标准元素被放在了未来排好序的数组中该标准元素应在的位置）然后，对这两个字数组中的元素分别再进行方法类同的递归快速排序。递归算法的结束条件是high &lt;= low，即上界下表小于或等于下界下标。</p>
<a id="more"></a>
<p>对快速排序 （挖坑填数）进行形象化总结：</p>
<ol>
<li>i = L; j = R; 将基准数（pivot）挖出形成第一个坑a[i]。</li>
<li>j– 由后向前找比它小的数，找到后挖出此数填入前一个坑a[i]中。</li>
<li>i++ 由前向后找比它大的数，找到后也挖出此数填入前一个坑a[j]中。</li>
<li>再重复之行2，3二步，直到i == j，将基准数（pivot）填入a[i]中。</li>
<li>递归调用上述步骤，直到数组中全部元素从小到大排序完成。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span></div><div class="line"><span class="comment">/* 用递归方法对数据元素a[low]~a[high]进行快速排序 */</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> i = low, j = high;</div><div class="line">    <span class="keyword">int</span> temp = a[low];</div><div class="line">    <span class="keyword">while</span> (i &lt; j)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">while</span>(i &lt; j &amp;&amp; temp &lt;= a[j]) j--; <span class="comment">//从数组右端扫描，找比基准小的数并赋给a[i]</span></div><div class="line">        <span class="keyword">if</span> (i &lt; j)</div><div class="line">        &#123;</div><div class="line">            a[i] = a[j];</div><div class="line">            i++;</div><div class="line">        &#125;</div><div class="line">       </div><div class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; a[i] &lt; temp) i++; <span class="comment">//从数组左端扫描，找比基准大的数并赋给a[j]</span></div><div class="line">        <span class="keyword">if</span> (i &lt; j)</div><div class="line">        &#123;</div><div class="line">            a[j] = a[i];</div><div class="line">            j--;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    a[i] = temp;</div><div class="line">    <span class="comment">/* 最后i == j */</span></div><div class="line">    <span class="keyword">if</span> (low &lt; i) QuickSort(a, low, i - <span class="number">1</span>);</div><div class="line">    <span class="keyword">if</span> (i &lt; high) QuickSort(a, j + <span class="number">1</span>, high);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="排序算法性能比较"><a href="#排序算法性能比较" class="headerlink" title="排序算法性能比较"></a>排序算法性能比较</h2><img src="/2017/02/01/quicksort/sort.jpg" alt="sort.jpg" title="">]]></content>
    
    <summary type="html">
    
      &lt;p&gt;快速排序（Quicksort) 在平均状况下，排序n个项目要O(nlogn)次比较。在最坏状况下则需要O(n2)次比较，但这种状况并不常见。它在排序效率同为O(nlogn)的几种排序方法中效率最高，因此经常被采用。&lt;/p&gt;
&lt;h2 id=&quot;算法思想&quot;&gt;&lt;a href=&quot;#算法思想&quot; class=&quot;headerlink&quot; title=&quot;算法思想&quot;&gt;&lt;/a&gt;算法思想&lt;/h2&gt;&lt;p&gt;设数组a中存放了n个数据元素，low为数组的低端下标，high为数组的高端下标，从数组a中任取一个元素（通常取a[low]）作为标准，调整数组a中各个元素的位置，使排在标准元素前面的元素的关键字均小于标准元素的关键字，排在标准元素后面的元素的关键字均大于或等于标准元素的关键字。（即标准元素被放在了未来排好序的数组中该标准元素应在的位置）然后，对这两个字数组中的元素分别再进行方法类同的递归快速排序。递归算法的结束条件是high &amp;lt;= low，即上界下表小于或等于下界下标。&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="排序" scheme="http://yoursite.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>hive与hbase的区别</title>
    <link href="http://yoursite.com/2017/02/01/hive-hbase/"/>
    <id>http://yoursite.com/2017/02/01/hive-hbase/</id>
    <published>2017-02-01T14:57:57.000Z</published>
    <updated>2017-02-04T12:36:36.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><ul>
<li>hive是一个构建在hadoop基础设施上的数据仓库，通过hive可以使用hql语言查询存放在hdfs上的数据。hql是一种类sql语言，这种语言最终被转化为map/reduce。虽然hive提供了sql查询功能，但是hive不能进行交互查询。（只能在hadoop上批量执行hadoop）</li>
<li>hbase是一种key/value系统，运行在hdfs之上。和hive不一样，hbase能够在数据库上实时运行，而不是运行map/reduce任务。hive被分区为表格，表格又被进一步分割为列簇。列簇必须使用schema定义，列簇将某一类型列集合起来。每一个key/value对在hbase中被定义为一个cell，每一个key由row-key，列簇，列和时间戳。在hbase中，行是key/value映射的集合，这个映射通过row-key来唯一标识。</li>
</ul>
<a id="more"></a>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul>
<li>hive帮助熟悉sql的人运行map/reduce任务。因为它是jdbc兼容的，同时它也能够和现存的sql工具整合一起。运行hive查询会花费很长时间，因为它会默认遍历表中所有数据。虽然有这样的缺点，一次遍历的数据量可以通过hive的分区机制来控制。分区允许在数据集上运行过滤查询，这些数据集存储在不同的文件夹内，查询的时候只遍历指定文件夹（分区）中的数据。</li>
<li>hbase通过存储key/value来工作。它支持四种主要的操作，增加或者更新行，查看一个范围内的cell，获取指定的行，删除指定的行、列或者列的版本。版本信息用来获取历史数据（每一行的历史数据可以被删除，然后通过hbase compaction就可以释放空间）。虽然hbase包括表格，但是schema仅仅被表格和列簇所要求，列不需要schema。hbase的表格包括增加／计数功能。</li>
</ul>
<h2 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h2><ul>
<li>hive目前不支持更新操作。另外，由于hive在hadoop上运行批量操作，它需要花费很长的时间，通常是几分钟到几个小时才可以获取到查询的结果。Hive必须提供预先定义好的schema将文件和目录映射到列，并且Hive与ACID不兼容。</li>
<li>HBase查询是通过特定的语言来编写的，这种语言需要重新学习。类SQL的功能可以通过Apache Phonenix实现，但这是以必须提供schema为代价的。另外，Hbase也并不是兼容所有的ACID特性，虽然它支持某些特性。最后但不是最重要的–为了运行Hbase，zookeeper是必须的，zookeeper是一个用来进行分布式协调的服务，这些服务包括配置服务，维护元信息和命名空间服务。</li>
</ul>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ul>
<li>Hive适合用来对一段时间内的数据进行分析查询，例如，用来计算趋势或者网站的日志。Hive不应该用来进行实时的查询。因为它需要很长时间才可以返回结果。</li>
<li>Hbase非常适合用来进行大数据的实时查询。Facebook用Hbase进行消息和实时的分析。它也可以用来统计Facebook的连接数。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Hive和Hbase是两种基于Hadoop的不同技术–Hive是一种类SQL的引擎，并且运行MapReduce任务，Hbase是一种在Hadoop之上的NoSQL 的Key/vale数据库。当然，这两种工具是可以同时使用的。就像用Google来搜索，用FaceBook进行社交一样，Hive可以用来进行统计查询，HBase可以用来进行实时查询，数据也可以从Hive写到Hbase，设置再从Hbase写回Hive。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;hive是一个构建在hadoop基础设施上的数据仓库，通过hive可以使用hql语言查询存放在hdfs上的数据。hql是一种类sql语言，这种语言最终被转化为map/reduce。虽然hive提供了sql查询功能，但是hive不能进行交互查询。（只能在hadoop上批量执行hadoop）&lt;/li&gt;
&lt;li&gt;hbase是一种key/value系统，运行在hdfs之上。和hive不一样，hbase能够在数据库上实时运行，而不是运行map/reduce任务。hive被分区为表格，表格又被进一步分割为列簇。列簇必须使用schema定义，列簇将某一类型列集合起来。每一个key/value对在hbase中被定义为一个cell，每一个key由row-key，列簇，列和时间戳。在hbase中，行是key/value映射的集合，这个映射通过row-key来唯一标识。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="数据处理" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"/>
    
    
      <category term="hive" scheme="http://yoursite.com/tags/hive/"/>
    
  </entry>
  
  <entry>
    <title>二叉树的非递归遍历</title>
    <link href="http://yoursite.com/2017/02/01/binary-tree-non-recursive-traversal/"/>
    <id>http://yoursite.com/2017/02/01/binary-tree-non-recursive-traversal/</id>
    <published>2017-02-01T05:19:19.000Z</published>
    <updated>2017-02-02T16:01:15.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="二叉树定义"><a href="#二叉树定义" class="headerlink" title="二叉树定义"></a>二叉树定义</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> TreeNode &#123;</div><div class="line"><span class="keyword">public</span></div><div class="line">    <span class="keyword">int</span> val;</div><div class="line">    TreeNode *left, *right;</div><div class="line">    TreeNode(<span class="keyword">int</span> val) &#123;</div><div class="line">        <span class="keyword">this</span> -&gt; val = val;</div><div class="line">        <span class="keyword">this</span> -&gt; left = <span class="keyword">this</span> -&gt; right = <span class="literal">NULL</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h2><p>根据前序遍历访问的顺序，优先访问根结点，然后再分别访问左孩子和右孩子。即对于任一结点，其可看做是根结点，因此可以直接访问，访问完之后，若其左孩子不为空，按相同规则访问它的左子树；当访问其左子树时，再访问它的右子树。因此其处理过程如下：</p>
<a id="more"></a>
<p>对于任一结点P：</p>
<ol>
<li>访问结点P，并将结点P入栈;</li>
<li>判断结点P的左孩子是否为空，若为空，则取栈顶结点并进行出栈操作，并将栈顶结点的右孩子置为当前的结点P，循环至1; 若不为空，则将P的左孩子置为当前的结点P;</li>
<li>直到P为NULL并且栈为空，则遍历结束。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">preorder1</span><span class="params">(TreeNode *root)</span> </span>&#123;</div><div class="line">    <span class="built_in">stack</span>&lt;TreeNode *&gt; s;</div><div class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    s.push(root);</div><div class="line">    <span class="keyword">while</span> (!s.empty()) &#123;</div><div class="line">        root = s.top();</div><div class="line">        s.pop();</div><div class="line">        <span class="comment">/* 访问根结点 */</span></div><div class="line">        <span class="built_in">cout</span> &lt;&lt; root -&gt; val &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">        <span class="comment">/* 右子结点先入栈 */</span></div><div class="line">        <span class="keyword">if</span> (root -&gt; right)</div><div class="line">            s.push(root -&gt; right);</div><div class="line">        <span class="comment">/* 左子结点后进栈 */</span></div><div class="line">        <span class="keyword">if</span> (root  -&gt; left)</div><div class="line">            s.push(root -&gt; left);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">preorder2</span><span class="params">(TreeNode *root)</span> </span>&#123;</div><div class="line">    <span class="built_in">stack</span>&lt;TreeNode *&gt; s;</div><div class="line">    <span class="keyword">while</span> (root != <span class="literal">NULL</span> || !s.empty()) &#123;</div><div class="line">        <span class="keyword">while</span> (root != <span class="literal">NULL</span>) &#123;</div><div class="line">            <span class="built_in">cout</span> &lt;&lt; root -&gt; val &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">            s.push(root);</div><div class="line">            root = root -&gt; left;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (!s.empty()) &#123;</div><div class="line">            root = s.top();</div><div class="line">            s.pop();</div><div class="line">            root = root -&gt; right;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h2><p>根据中序遍历的顺序，对于任一结点，优先访问其左孩子，而左孩子结点又可以看做一根结点，然后继续访问其左孩子结点，直到遇到左孩子结点为空的结点才进行访问，然后按相同的规则访问其右子树。因此其处理过程如下：</p>
<p>对于任一结点P，</p>
<ol>
<li>若其左孩子不为空，则将P入栈并将P的左孩子置为当前的P，然后对当前结点P再进行相同的处理；</li>
<li>若其左孩子为空，则取栈顶元素并进行出栈操作，访问该栈顶结点，然后将当前的P置为栈顶结点的右孩子;</li>
<li>直到P为NULL并且栈为空则遍历结束。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">inorder</span><span class="params">(TreeNode *root)</span> </span>&#123;</div><div class="line">    <span class="built_in">stack</span>&lt;TreeNode *&gt; s;</div><div class="line">    <span class="keyword">while</span> (!s.empty() || root != <span class="literal">NULL</span>) &#123;</div><div class="line">      	<span class="comment">/* 首先根结点入栈，然后左子结点入栈 */</span></div><div class="line">        <span class="keyword">while</span> (root != <span class="literal">NULL</span>) &#123;       </div><div class="line">            s.push(root);</div><div class="line">            root = root -&gt; left;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (root != <span class="literal">NULL</span>) &#123;</div><div class="line">            root = s.top();</div><div class="line">            s.pop();</div><div class="line">            <span class="built_in">cout</span> &lt;&lt; root -&gt; val &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">            root  = root -&gt; right;</div><div class="line">        &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h2><p>后序遍历的非递归实现是三种遍历方式中最难的一种。因为在后序遍历中，要保证左孩子和右孩子都已被访问并且左孩子在右孩子前访问才能访问根结点，这就为流程的控制带来了难题。</p>
<p>第一种思路：对于任一结点P，将其入栈，然后沿其左子树一直往下搜索，直到搜索到没有左孩子的结点，此时该结点出现在栈顶，但是此时不能将其出栈并访问，因此其右孩子还为被访问。所以接下来按照相同的规则对其右子树进行相同的处理，当访问完其右孩子时，该结点又出现在栈顶，此时可以将其出栈并访问。这样就保证了正确的访问顺序。可以看出，在这个过程中，每个结点都两次出现在栈顶，只有在第二次出现在栈顶时，才能访问它。因此需要多设置一个变量标识该结点是否是第一次出现在栈顶。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> StackNode &#123;</div><div class="line">    TreeNode *root;</div><div class="line">    <span class="keyword">bool</span> isFirst; <span class="comment">// 增加状态变量</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/* visit(left) -&gt; visit(right) -&gt; root */</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">postorder</span><span class="params">(TreeNode *root)</span> </span>&#123;</div><div class="line">    <span class="built_in">stack</span>&lt;StackNode&gt; s;</div><div class="line">    StackNode snode;</div><div class="line">    <span class="keyword">while</span> (!s.empty() || root != <span class="literal">NULL</span>) &#123;</div><div class="line">        <span class="comment">/* 有左孩子，则进栈，将root赋值为root -&gt; left */</span></div><div class="line">        <span class="keyword">while</span> (root != <span class="literal">NULL</span>) &#123;</div><div class="line">            snode.isFirst = <span class="literal">true</span>;</div><div class="line">            snode.root = root;</div><div class="line">            s.push(snode);</div><div class="line">            root = root -&gt; left;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (!s.empty()) &#123;</div><div class="line">            snode = s.top();</div><div class="line">            s.pop();</div><div class="line">            <span class="comment">/* 栈顶第一次出现某结点，先pop()再push()，将root赋值为root -&gt; right */</span></div><div class="line">            <span class="keyword">if</span> (snode.isFirst) &#123;</div><div class="line">                snode.isFirst = <span class="literal">false</span>;</div><div class="line">                s.push(snode);</div><div class="line">                root = snode.root -&gt; right;</div><div class="line">                <span class="comment">/* 结点会出现在栈顶两次，访问结点 */</span></div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="built_in">cout</span> &lt;&lt; snode.root -&gt; val &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">                root = <span class="literal">NULL</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>第二种思路：要保证根结点在左孩子和右孩子访问之后才能访问，因此对于任一结点P，先将其入栈。如果P不存在左孩子和右孩子，则可以直接访问它；或者P存在左孩子或者右孩子，但是其左孩子和右孩子都已被访问过了，则同样可以直接访问该结点。若非上述两种情况，则将P的右孩子和左孩子依次入栈，这样就保证了每次取栈顶元素的时候，左孩子在右孩子前面被访问，左孩子和右孩子都在根结点前面被访问。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">postorder</span><span class="params">(TreeNode *root)</span> </span>&#123;</div><div class="line">    <span class="built_in">stack</span>&lt;TreeNode *&gt; s;</div><div class="line">    TreeNode *cur, *pre = <span class="literal">NULL</span>;</div><div class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    s.push(root);</div><div class="line">    <span class="keyword">while</span> (!s.empty()) &#123;</div><div class="line">        cur = s.top();</div><div class="line">      	<span class="comment">/* cur不存在左孩子和右孩子 */</span></div><div class="line">        <span class="keyword">if</span> ((cur -&gt; left == <span class="literal">NULL</span> &amp;&amp; cur -&gt; right == <span class="literal">NULL</span>) ||</div><div class="line">            pre != <span class="literal">NULL</span> &amp;&amp; (pre == cur -&gt; left || pre == cur -&gt; right)) &#123;</div><div class="line">                <span class="built_in">cout</span> &lt;&lt; cur -&gt; val &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">                s.pop();</div><div class="line">                pre = cur;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">if</span> (cur -&gt; left)</div><div class="line">                s.push(cur -&gt; left);</div><div class="line">            <span class="keyword">if</span> (cur -&gt; right)</div><div class="line">                s.push(cur -&gt; right);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="三合一非递归遍历"><a href="#三合一非递归遍历" class="headerlink" title="三合一非递归遍历"></a>三合一非递归遍历</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> StackNode1 &#123;</div><div class="line">    TreeNode *root;</div><div class="line">    <span class="keyword">int</span> state; <span class="comment">// 增加状态变量</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">inorder</span><span class="params">(TreeNode *root)</span> </span>&#123;</div><div class="line">    StackNode1 snode;</div><div class="line">    snode.root = root;</div><div class="line">    snode.state = <span class="number">0</span>;</div><div class="line">    <span class="built_in">stack</span>&lt;StackNode1&gt; s;</div><div class="line">    <span class="keyword">while</span> (snode.root != <span class="literal">NULL</span> &amp;&amp; !s.empty()) &#123;</div><div class="line">        <span class="keyword">while</span> (!s.empty() &amp;&amp; (snode.root == <span class="literal">NULL</span> || snode.state &gt;= <span class="number">3</span>)) &#123;</div><div class="line">            snode = s.top();</div><div class="line">            s.pop();</div><div class="line">            snode.state++;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (snode.root == <span class="literal">NULL</span> || snode.state &gt;= <span class="number">3</span>)</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="comment">/* 当前是中序遍历，前序遍历和后序遍历只需更改case的值 */</span></div><div class="line">        <span class="comment">/* 前序遍历：case 1 -&gt; case 0 -&gt; case 2 */</span></div><div class="line">        <span class="comment">/* 后序遍历：case 1 -&gt; case 2 -&gt; case 0 */</span></div><div class="line">        <span class="keyword">switch</span> (snode.state) &#123;</div><div class="line">            <span class="keyword">case</span> <span class="number">0</span>:</div><div class="line">                s.push(snode);</div><div class="line">                snode.root = snode.root -&gt; left;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> <span class="number">1</span>:</div><div class="line">                <span class="built_in">cout</span> &lt;&lt; snode.root -&gt; val &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">                snode.state++;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> <span class="number">2</span>:</div><div class="line">                s.push(snode);</div><div class="line">                snode.root = snode.root -&gt; right;</div><div class="line">                snode.state = <span class="number">0</span>;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">default</span>:</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;二叉树定义&quot;&gt;&lt;a href=&quot;#二叉树定义&quot; class=&quot;headerlink&quot; title=&quot;二叉树定义&quot;&gt;&lt;/a&gt;二叉树定义&lt;/h2&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; TreeNode &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; val;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    TreeNode *left, *right;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    TreeNode(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; val) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt; -&amp;gt; val = val;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt; -&amp;gt; left = &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt; -&amp;gt; right = &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;前序遍历&quot;&gt;&lt;a href=&quot;#前序遍历&quot; class=&quot;headerlink&quot; title=&quot;前序遍历&quot;&gt;&lt;/a&gt;前序遍历&lt;/h2&gt;&lt;p&gt;根据前序遍历访问的顺序，优先访问根结点，然后再分别访问左孩子和右孩子。即对于任一结点，其可看做是根结点，因此可以直接访问，访问完之后，若其左孩子不为空，按相同规则访问它的左子树；当访问其左子树时，再访问它的右子树。因此其处理过程如下：&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="二叉树" scheme="http://yoursite.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
</feed>
