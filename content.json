{"meta":{"title":"QtTao's Blog","subtitle":"翩若惊鸿 婉若游龙","description":null,"author":"Qitian Tao","url":"http://yoursite.com"},"pages":[{"title":"About Me","date":"2017-02-02T15:03:03.000Z","updated":"2017-02-02T15:10:37.000Z","comments":false,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"陶啟添，男，来自广东佛山90后，听港乐，看动漫平日喜欢折腾代码，懂点Python和C/C++希望成为一名合格的全栈，通过技术改变生活"},{"title":"分类标签","date":"2017-02-02T15:35:52.000Z","updated":"2017-02-02T15:36:27.000Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"堆排序","slug":"heapsort","date":"2017-02-02T15:55:13.000Z","updated":"2017-02-02T16:01:34.000Z","comments":true,"path":"2017/02/02/heapsort/","link":"","permalink":"http://yoursite.com/2017/02/02/heapsort/","excerpt":"","text":"算法思想首先把有n个元素的数组a初始化创建为最大堆，然后循环执行如下过程直到数组为空为止： 把堆顶a[0]元素（为最大元素）和当前最大堆的最后一个元素交换； 最大堆元素个数减一； 由于第一步后根结点不再满足最大堆的定义，因此调整根结点使之满足最大堆的定义； 1234567891011121314151617181920212223242526void CreateHeap(int a[], int n, int h) &#123;/* 当完全二叉树中某个非叶结点a[h]（h = (n - 2)/2）的左孩子结点a[2h + 1]和右孩子结点a[2h + 2]都已是最大堆后，调整一个非叶结点a[h]使之满足最大堆。 */ int i, j, flag; int temp; /* i为要建堆的二叉树根结点下标 */ i = h; /* j为i的左孩子结点的下标 */ j = 2 * i + 1; temp = a[i]; flag = 0; /* 沿左右孩子中值较大者重复向下筛选 */ while (j &lt; n &amp;&amp; flag != 1) &#123; /* 寻找左右孩子结点中较大者， */ if (j &lt; n - 1 &amp;&amp; a[j] &lt; a[j + 1]) j++; if (temp &gt; a[i]) &#123; flag = 1; /* 否则把a[j]上移 */ &#125; else &#123; a[i] = a[j]; i = j; j = 2 * i + 1; &#125; &#125; a[i] = temp;&#125; 123456void InitCreateHeap(int a[], int n) &#123; /* 把数组元素a[0]~a[n - 1]初始化创建为最大堆 */ int i; for (i = (n - 2)/2; i &gt;= 0; i--) CreateHeap(a, n, i);&#125; 123456789101112131415void HeapSort(int a[], int n) &#123; int i; int temp; /* 初始化创建最大堆 */ InitCreateHeap(a, n); /* 当前最大堆个数每次递减一 */ for (i = n - 1; i &gt; 0; i--) &#123; temp = a[0]; a[0] = a[i]; a[i] = temp; /* 调整根结点满足最大堆 */ /* 子二叉树的根结点下标为零，结点个数为i */ CreateHeap(a, i, 0); &#125;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/数据结构/"}],"tags":[{"name":"排序","slug":"排序","permalink":"http://yoursite.com/tags/排序/"}]},{"title":"关于图的知识点","slug":"graph","date":"2017-02-01T15:18:10.000Z","updated":"2017-02-02T16:00:26.000Z","comments":true,"path":"2017/02/01/graph/","link":"","permalink":"http://yoursite.com/2017/02/01/graph/","excerpt":"图的存储结构 邻接矩阵（稠密矩阵：点少边多的情况） 邻接表 （稀疏矩阵：点多边少的情况） 图的遍历 深度优先 123456789101112131415void DepthFSearch(AdjMGraph G, int v, int visited[], void Visit(char item))&#123; int w; Vist(G.Vertices.list[v]); visited[v]; w = GetFirstVex(G, v); /* 寻找当前顶点的邻接顶点 */ while (w != -1) &#123; if (!visited[w]) DepthFSearch(G, w, visited, Visit) /* 若邻接顶点已被访问，则寻找下一个邻接顶点 */ w = GetNextVex(G, v, w); &#125;&#125;","text":"图的存储结构 邻接矩阵（稠密矩阵：点少边多的情况） 邻接表 （稀疏矩阵：点多边少的情况） 图的遍历 深度优先 123456789101112131415void DepthFSearch(AdjMGraph G, int v, int visited[], void Visit(char item))&#123; int w; Vist(G.Vertices.list[v]); visited[v]; w = GetFirstVex(G, v); /* 寻找当前顶点的邻接顶点 */ while (w != -1) &#123; if (!visited[w]) DepthFSearch(G, w, visited, Visit) /* 若邻接顶点已被访问，则寻找下一个邻接顶点 */ w = GetNextVex(G, v, w); &#125;&#125; 广度优先 1234567891011121314151617181920212223242526void BoardFSearch(AdjMGraph G, int v, int visited[], void Visit(char item))&#123; int u, w; SeqCQueue queue; QueueInitiate(&amp;queue); Visit(G.Vertices.list[v]); visited[v]; QueueAppend(&amp;queue, v); /* 当队列为空时终止循环 */ while(QueueNotEmpty(queue)) &#123; QueueDelete(&amp;queue, &amp;u); w = GetFirstVex(G, u); /* 遍历所有邻接顶点 */ while(w != -1) &#123; if (!visited[w]) &#123; Visit(G.Vertices.list[w]); // 访问顶点w visited[w]; // 标记顶点w QueueAppend(&amp;queue, w); // 顶点w入队列 &#125; w = GetNextVex(G, u, w); &#125; &#125;&#125; 最小生成树－无向带权连通图对于无向带权连通图，其所有生成树中边的权值总和最小的是最小生成树。例如在n个城市之间敷设光缆，且各城市之间敷设光缆的费用不同。 n个顶点的无向连通带权图的最小生成树必须满足如下条件： 包括n个顶点 有且只有n - 1条边 不存在回路 经典算法 Prim algorithm （点少边多，稠密矩阵） 1234567891011121314151617181920212223242526272829303132333435363738typedef struct&#123; Vert vertex; int weight;&#125; MinSpanTree;void Prim(AdjMGraph G, MinSpanTree closeVertex[])&#123; Vert x; int i, j, k; int minCost; int n = G.Vertices.size; int * lowCost = (int *)malloc(sizeof(int) * n); for (i = 1; i &lt; n; i ++) lowCost[i] = G.edge[0][i]; lowCost[0] = -1; listGet(G.Vertices, 0, &amp;x); closeVertex[0].vertex = x; for (i = 1; i &lt; n; i++) &#123; minCost = MaxWeight; // MaxWeight为定义的最大权值 /* 寻找当前最小权值的边所对应的顶点k，但不包括lowCost = -1的 */ for (j = 1; j &lt; n; j++) if (minCost &gt; lowCost[j] &amp;&amp; lowCost[j] &gt; 0) &#123; k = j; minCost = lowCost[j]; &#125; listGet(G.Vertices, k, &amp;x); closeVertex[i].vertex = x; closeVertex[i].weight = minCost; lowCost[k] = -1; /* 更新权值 */ for (j = 1; j &lt; n; j++) if (lowCost[j] &gt; G.edge[k][j]) lowCost = G.edge[k][j]; &#125;&#125; Kruskal算法（点多边少，稀疏矩阵）：首先是带权图中各边的权值排序，其次是判断新选取的边的两个顶点是否属于同一个连通分量。 最短路径－有向带权图（连通／非连通）经典算法 Dijkstra algorithm：按路径长度递增的顺序逐步产生最短路径的构造算法 1234567891011121314151617181920212223242526272829303132333435363738void Dijkstra(AdjMGraph G, int v0, int distance[], int path[])/* s[]用来表示顶点是否已从集合T移动到集合S中 *//* path[]存放了从原点v0到其它各个顶点的最短路径的前一个顶点的下标 */&#123; int n = G.Vertices.size; int * s = (int *)malloc(sizeof(int) * n); int minDis, i, j, k; /* Initilization */ for (i = 0; i &lt; n; i++) &#123; distance[i] = G.edge[v0][j]; s[i] = 0; if (i != v0 &amp;&amp; distance[i] &lt; MaxWeight) path[i] = v0; else path[i] = -1; &#125; s[v0] = 1; /* 对于连通图来说，每一个循环能找到一个路径最短的顶点 */ for (i = 1; i &lt; n; i++) &#123; minDis = MaxWeight; for (j = 0; j &lt; n; j++) &#123; if (s[i] == 0 &amp;&amp; minDis &gt; distance[j]) &#123; k = j; minDis = distance[j]; &#125; &#125; /* 当不再存在路径时，算法结束。此语句对非连通图是必需的 */ if (minDis == MaxWeight) return; s[k] = 1; /* 修改从v0到其它顶点的最短路径 */ for (j = 0; j &lt; n; j++) if (s[i] == 0 &amp;&amp; G.edge[k][j] &lt; MaxWeight &amp;&amp; distance[k] + G.edge[k][j] &lt; distance[j]) distance[j] = distance[k] + G.edge[k][j]; path[j] = k; &#125;&#125; Floyd algorithm：解决每对顶点之间最短路径的算法。","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/数据结构/"}],"tags":[{"name":"图","slug":"图","permalink":"http://yoursite.com/tags/图/"}]},{"title":"快速排序","slug":"quicksort","date":"2017-02-01T15:07:16.000Z","updated":"2017-02-02T15:59:08.000Z","comments":true,"path":"2017/02/01/quicksort/","link":"","permalink":"http://yoursite.com/2017/02/01/quicksort/","excerpt":"快速排序（Quicksort) 在平均状况下，排序n个项目要O(nlogn)次比较。在最坏状况下则需要O(n2)次比较，但这种状况并不常见。它在排序效率同为O(nlogn)的几种排序方法中效率最高，因此经常被采用。 算法思想设数组a中存放了n个数据元素，low为数组的低端下标，high为数组的高端下标，从数组a中任取一个元素（通常取a[low]）作为标准，调整数组a中各个元素的位置，使排在标准元素前面的元素的关键字均小于标准元素的关键字，排在标准元素后面的元素的关键字均大于或等于标准元素的关键字。（即标准元素被放在了未来排好序的数组中该标准元素应在的位置）然后，对这两个字数组中的元素分别再进行方法类同的递归快速排序。递归算法的结束条件是high &lt;= low，即上界下表小于或等于下界下标。","text":"快速排序（Quicksort) 在平均状况下，排序n个项目要O(nlogn)次比较。在最坏状况下则需要O(n2)次比较，但这种状况并不常见。它在排序效率同为O(nlogn)的几种排序方法中效率最高，因此经常被采用。 算法思想设数组a中存放了n个数据元素，low为数组的低端下标，high为数组的高端下标，从数组a中任取一个元素（通常取a[low]）作为标准，调整数组a中各个元素的位置，使排在标准元素前面的元素的关键字均小于标准元素的关键字，排在标准元素后面的元素的关键字均大于或等于标准元素的关键字。（即标准元素被放在了未来排好序的数组中该标准元素应在的位置）然后，对这两个字数组中的元素分别再进行方法类同的递归快速排序。递归算法的结束条件是high &lt;= low，即上界下表小于或等于下界下标。 对快速排序 （挖坑填数）进行形象化总结： i = L; j = R; 将基准数（pivot）挖出形成第一个坑a[i]。 j– 由后向前找比它小的数，找到后挖出此数填入前一个坑a[i]中。 i++ 由前向后找比它大的数，找到后也挖出此数填入前一个坑a[j]中。 再重复之行2，3二步，直到i == j，将基准数（pivot）填入a[i]中。 递归调用上述步骤，直到数组中全部元素从小到大排序完成。 1234567891011121314151617181920212223242526void QuickSort(int a[], int low, int high)/* 用递归方法对数据元素a[low]~a[high]进行快速排序 */&#123; int i = low, j = high; int temp = a[low]; while (i &lt; j) &#123; while(i &lt; j &amp;&amp; temp &lt;= a[j]) j--; //从数组右端扫描，找比基准小的数并赋给a[i] if (i &lt; j) &#123; a[i] = a[j]; i++; &#125; while (i &lt; j &amp;&amp; a[i] &lt; temp) i++; //从数组左端扫描，找比基准大的数并赋给a[j] if (i &lt; j) &#123; a[j] = a[i]; j--; &#125; &#125; a[i] = temp; /* 最后i == j */ if (low &lt; i) QuickSort(a, low, i - 1); if (i &lt; high) QuickSort(a, j + 1, high);&#125; 排序算法性能比较","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/数据结构/"}],"tags":[{"name":"排序","slug":"排序","permalink":"http://yoursite.com/tags/排序/"}]},{"title":"hive与hbase的区别","slug":"hive-hbase","date":"2017-02-01T14:57:57.000Z","updated":"2017-02-02T15:59:47.000Z","comments":true,"path":"2017/02/01/hive-hbase/","link":"","permalink":"http://yoursite.com/2017/02/01/hive-hbase/","excerpt":"定义 hive是一个构件在hadoop基础设施上的数据仓库，通过hive可以使用hql语言查询存放在hdfs上的数据。hql是一种类sql语言，这种语言最终被转化为map/reduce。虽然hive提供了sql查询功能，但是hive不能进行交互查询。（只能在hadoop上批量执行hadoop） hbase是一种key/value系统，运行在hdfs之上。和hive不一样，hbase能够在数据库上实时运行，而不是运行map/reduce任务。hive被分区为表格，表格又被进一步分割为列簇。列簇必须使用schema定义，列簇将某一类型列集合起来。每一个key/value对在hbase中被定义为一个cell，每一个key由row-key，列簇，列和时间戳。在hbase中，行是key/value映射的集合，这个映射通过row-key来唯一标识。","text":"定义 hive是一个构件在hadoop基础设施上的数据仓库，通过hive可以使用hql语言查询存放在hdfs上的数据。hql是一种类sql语言，这种语言最终被转化为map/reduce。虽然hive提供了sql查询功能，但是hive不能进行交互查询。（只能在hadoop上批量执行hadoop） hbase是一种key/value系统，运行在hdfs之上。和hive不一样，hbase能够在数据库上实时运行，而不是运行map/reduce任务。hive被分区为表格，表格又被进一步分割为列簇。列簇必须使用schema定义，列簇将某一类型列集合起来。每一个key/value对在hbase中被定义为一个cell，每一个key由row-key，列簇，列和时间戳。在hbase中，行是key/value映射的集合，这个映射通过row-key来唯一标识。 特点 hive帮助熟悉sql的人运行map/reduce任务。因为它是jdbc兼容的，同时它也能够和现存的sql工具整合一起。运行hive查询会花费很长时间，因为它会默认遍历表中所有数据。虽然有这样的缺点，一次遍历的数据量可以通过hive的分区机制来控制。分区允许在数据集上运行过滤查询，这些数据集存储在不同的文件夹内，查询的时候只遍历指定文件夹（分区）中的数据。 hbase通过存储key/value来工作。它支持四种主要的操作，增加或者更新行，查看一个范围内的cell，获取指定的行，删除指定的行、列或者列的版本。版本信息用来获取历史数据（每一行的历史数据可以被删除，然后通过hbase compaction就可以释放空间）。虽然hbase包括表格，但是schema仅仅被表格和列簇所要求，列不需要schema。hbase的表格包括增加／计数功能。 限制 hive目前不支持更新操作。另外，由于hive在hadoop上运行批量操作，它需要花费很长的时间，通常是几分钟到几个小时才可以获取到查询的结果。Hive必须提供预先定义好的schema将文件和目录映射到列，并且Hive与ACID不兼容。 HBase查询是通过特定的语言来编写的，这种语言需要重新学习。类SQL的功能可以通过Apache Phonenix实现，但这是以必须提供schema为代价的。另外，Hbase也并不是兼容所有的ACID特性，虽然它支持某些特性。最后但不是最重要的–为了运行Hbase，zookeeper是必须的，zookeeper是一个用来进行分布式协调的服务，这些服务包括配置服务，维护元信息和命名空间服务。 应用场景 Hive适合用来对一段时间内的数据进行分析查询，例如，用来计算趋势或者网站的日志。Hive不应该用来进行实时的查询。因为它需要很长时间才可以返回结果。 Hbase非常适合用来进行大数据的实时查询。Facebook用Hbase进行消息和实时的分析。它也可以用来统计Facebook的连接数。 总结Hive和Hbase是两种基于Hadoop的不同技术–Hive是一种类SQL的引擎，并且运行MapReduce任务，Hbase是一种在Hadoop之上的NoSQL 的Key/vale数据库。当然，这两种工具是可以同时使用的。就像用Google来搜索，用FaceBook进行社交一样，Hive可以用来进行统计查询，HBase可以用来进行实时查询，数据也可以从Hive写到Hbase，设置再从Hbase写回Hive。","categories":[{"name":"数据处理","slug":"数据处理","permalink":"http://yoursite.com/categories/数据处理/"}],"tags":[{"name":"hive","slug":"hive","permalink":"http://yoursite.com/tags/hive/"}]},{"title":"二叉树的非递归遍历","slug":"binary-tree-non-recursive-traversal","date":"2017-02-01T05:19:19.000Z","updated":"2017-02-02T16:01:15.000Z","comments":true,"path":"2017/02/01/binary-tree-non-recursive-traversal/","link":"","permalink":"http://yoursite.com/2017/02/01/binary-tree-non-recursive-traversal/","excerpt":"二叉树定义123456789class TreeNode &#123;public int val; TreeNode *left, *right; TreeNode(int val) &#123; this -&gt; val = val; this -&gt; left = this -&gt; right = NULL; &#125;&#125; 前序遍历根据前序遍历访问的顺序，优先访问根结点，然后再分别访问左孩子和右孩子。即对于任一结点，其可看做是根结点，因此可以直接访问，访问完之后，若其左孩子不为空，按相同规则访问它的左子树；当访问其左子树时，再访问它的右子树。因此其处理过程如下：","text":"二叉树定义123456789class TreeNode &#123;public int val; TreeNode *left, *right; TreeNode(int val) &#123; this -&gt; val = val; this -&gt; left = this -&gt; right = NULL; &#125;&#125; 前序遍历根据前序遍历访问的顺序，优先访问根结点，然后再分别访问左孩子和右孩子。即对于任一结点，其可看做是根结点，因此可以直接访问，访问完之后，若其左孩子不为空，按相同规则访问它的左子树；当访问其左子树时，再访问它的右子树。因此其处理过程如下： 对于任一结点P： 访问结点P，并将结点P入栈; 判断结点P的左孩子是否为空，若为空，则取栈顶结点并进行出栈操作，并将栈顶结点的右孩子置为当前的结点P，循环至1; 若不为空，则将P的左孩子置为当前的结点P; 直到P为NULL并且栈为空，则遍历结束。 12345678910111213141516171819202122232425262728293031323334void preorder1(TreeNode *root) &#123; stack&lt;TreeNode *&gt; s; if (root == NULL) return; s.push(root); while (!s.empty()) &#123; root = s.top(); s.pop(); /* 访问根结点 */ cout &lt;&lt; root -&gt; val &lt;&lt; endl; /* 右子结点先入栈 */ if (root -&gt; right) s.push(root -&gt; right); /* 左子结点后进栈 */ if (root -&gt; left) s.push(root -&gt; left); &#125;&#125;void preorder2(TreeNode *root) &#123; stack&lt;TreeNode *&gt; s; while (root != NULL || !s.empty()) &#123; while (root != NULL) &#123; cout &lt;&lt; root -&gt; val &lt;&lt; endl; s.push(root); root = root -&gt; left; &#125; if (!s.empty()) &#123; root = s.top(); s.pop(); root = root -&gt; right; &#125; &#125;&#125; 中序遍历根据中序遍历的顺序，对于任一结点，优先访问其左孩子，而左孩子结点又可以看做一根结点，然后继续访问其左孩子结点，直到遇到左孩子结点为空的结点才进行访问，然后按相同的规则访问其右子树。因此其处理过程如下： 对于任一结点P， 若其左孩子不为空，则将P入栈并将P的左孩子置为当前的P，然后对当前结点P再进行相同的处理； 若其左孩子为空，则取栈顶元素并进行出栈操作，访问该栈顶结点，然后将当前的P置为栈顶结点的右孩子; 直到P为NULL并且栈为空则遍历结束。 123456789101112131415void inorder(TreeNode *root) &#123; stack&lt;TreeNode *&gt; s; while (!s.empty() || root != NULL) &#123; /* 首先根结点入栈，然后左子结点入栈 */ while (root != NULL) &#123; s.push(root); root = root -&gt; left; &#125; if (root != NULL) &#123; root = s.top(); s.pop(); cout &lt;&lt; root -&gt; val &lt;&lt; endl; root = root -&gt; right; &#125;&#125; 后序遍历后序遍历的非递归实现是三种遍历方式中最难的一种。因为在后序遍历中，要保证左孩子和右孩子都已被访问并且左孩子在右孩子前访问才能访问根结点，这就为流程的控制带来了难题。 第一种思路：对于任一结点P，将其入栈，然后沿其左子树一直往下搜索，直到搜索到没有左孩子的结点，此时该结点出现在栈顶，但是此时不能将其出栈并访问，因此其右孩子还为被访问。所以接下来按照相同的规则对其右子树进行相同的处理，当访问完其右孩子时，该结点又出现在栈顶，此时可以将其出栈并访问。这样就保证了正确的访问顺序。可以看出，在这个过程中，每个结点都两次出现在栈顶，只有在第二次出现在栈顶时，才能访问它。因此需要多设置一个变量标识该结点是否是第一次出现在栈顶。 123456789101112131415161718192021222324252627282930313233struct StackNode &#123; TreeNode *root; bool isFirst; // 增加状态变量&#125;/* visit(left) -&gt; visit(right) -&gt; root */void postorder(TreeNode *root) &#123; stack&lt;StackNode&gt; s; StackNode snode; while (!s.empty() || root != NULL) &#123; /* 有左孩子，则进栈，将root赋值为root -&gt; left */ while (root != NULL) &#123; snode.isFirst = true; snode.root = root; s.push(snode); root = root -&gt; left; &#125; if (!s.empty()) &#123; snode = s.top(); s.pop(); /* 栈顶第一次出现某结点，先pop()再push()，将root赋值为root -&gt; right */ if (snode.isFirst) &#123; snode.isFirst = false; s.push(snode); root = snode.root -&gt; right; /* 结点会出现在栈顶两次，访问结点 */ &#125; else &#123; cout &lt;&lt; snode.root -&gt; val &lt;&lt; endl; root = NULL; &#125; &#125; &#125;&#125; 第二种思路：要保证根结点在左孩子和右孩子访问之后才能访问，因此对于任一结点P，先将其入栈。如果P不存在左孩子和右孩子，则可以直接访问它；或者P存在左孩子或者右孩子，但是其左孩子和右孩子都已被访问过了，则同样可以直接访问该结点。若非上述两种情况，则将P的右孩子和左孩子依次入栈，这样就保证了每次取栈顶元素的时候，左孩子在右孩子前面被访问，左孩子和右孩子都在根结点前面被访问。 12345678910111213141516171819202122void postorder(TreeNode *root) &#123; stack&lt;TreeNode *&gt; s; TreeNode *cur, *pre = NULL; if (root == NULL) return; s.push(root); while (!s.empty()) &#123; cur = s.top(); /* cur不存在左孩子和右孩子 */ if ((cur -&gt; left == NULL &amp;&amp; cur -&gt; right == NULL) || pre != NULL &amp;&amp; (pre == cur -&gt; left || pre == cur -&gt; right)) &#123; cout &lt;&lt; cur -&gt; val &lt;&lt; endl; s.pop(); pre = cur; &#125; else &#123; if (cur -&gt; left) s.push(cur -&gt; left); if (cur -&gt; right) s.push(cur -&gt; right); &#125; &#125;&#125; 三合一非递归遍历12345678910111213141516171819202122232425262728293031323334353637383940struct StackNode1 &#123; TreeNode *root; int state; // 增加状态变量&#125;void inorder(TreeNode *root) &#123; StackNode1 snode; snode.root = root; snode.state = 0; stack&lt;StackNode1&gt; s; while (snode.root != NULL &amp;&amp; !s.empty()) &#123; while (!s.empty() &amp;&amp; (snode.root == NULL || snode.state &gt;= 3)) &#123; snode = s.top(); s.pop(); snode.state++; &#125; if (snode.root == NULL || snode.state &gt;= 3) break; /* 当前是中序遍历，前序遍历和后序遍历只需更改case的值 */ /* 前序遍历：case 1 -&gt; case 0 -&gt; case 2 */ /* 后序遍历：case 1 -&gt; case 2 -&gt; case 0 */ switch (snode.state) &#123; case 0: s.push(snode); snode.root = snode.root -&gt; left; break; case 1: cout &lt;&lt; snode.root -&gt; val &lt;&lt; endl; snode.state++; break; case 2: s.push(snode); snode.root = snode.root -&gt; right; snode.state = 0; break; default: break; &#125; &#125;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/数据结构/"}],"tags":[{"name":"二叉树","slug":"二叉树","permalink":"http://yoursite.com/tags/二叉树/"}]}]}